# MonoExploit
 NLog의 취약점을 이용하여 앱 도메인에 어셈블리를 로드합니다. 
   ![](https://i.imgur.com/vEv9xTH.png)
   
## 개요 
 기본적으로 .Net에서 제공하는 Assembly.Load함수를 이용하면 다른 어셈블리를 AppDomain에 연결시킬 수 있습니다.   
 다만, Assembly.Load를 프로세스 자체적으로 호출 하는 라이브러리를 찾으면 게임을 쉽게 해킹할 수 있습니다. 
 
 Mono 빌드에서 NLog를 사용하는 경우의 취약점이며, 어플리케이션이 dll 로드를 허용하는 부분이기에
 안티치트를 도입해도 취약할 수 있는 부분입니다.
 
 
## NLog를 사용하는 Assembly.Load의 취약점 해킹하기
 **NLog** 내부의 ConfigurationItemFactory.cs를 확인해봅시다.
 
```cs
 private static void LoadNLogExtensionAssemblies(
      ConfigurationItemFactory factory,
      Assembly nlogAssembly,
      string[] extensionDlls)
    {
      HashSet<string> stringSet = new HashSet<string>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase)
      {
        nlogAssembly.FullName
      };
      foreach (string extensionDll in extensionDlls)
      {
        InternalLogger.Info<string>("Auto loading assembly file: {0}", extensionDll);
        bool flag = false;
        try
        {
          Assembly assembly = AssemblyHelpers.LoadFromPath(extensionDll, (string) null);
          InternalLogger.LogAssemblyVersion(assembly);
          factory.RegisterItemsFromAssembly(assembly);
          stringSet.Add(assembly.FullName);
          flag = true;
        }
        catch (Exception ex)
        {
          if (ex.MustBeRethrownImmediately())
          {
            throw;
          }
          else
          {
            object[] objArray = new object[1]
            {
              (object) extensionDll
            };
            InternalLogger.Warn(ex, "Auto loading assembly file: {0} failed! Skipping this file.", objArray);
          }
        }
        if (flag)
          InternalLogger.Info<string>("Auto loading assembly file: {0} succeeded!", extensionDll);
      }
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
    }
```
    
    잘 보면 맨 아래에 아래와같은 코드를 확인 할 수 있습니다.
    
    
```cs
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
``` 
 
    
  
   NLog로 시작하는 DLL파일을 Assembly.Load시키는 명령입니다. 위 코드는 NLog가 Initalize될때 NLog로 시작하는 dll이 있으면 앱 도메인에 연결시킵니다.
   이걸실제 게임에 적용하는 방법입니다.
   
   일단 아래와 같은 코드를 작성합니다
   
   ```cs
   using NLog.Targets;
[Target(nameof(NLogTarget))] 
public sealed class NLogTarget : TargetWithLayout
{ 
    public NLogTarget()
    {
        StaticLoader.StaticLoad();
    }
}
   ```
  위 코드는 Target Attribute를 적용하고 TargetWithLayout을 상속시켜 NLog가 해당 .ctor를 자동 호출하게 만듭니다.
  그다음 아래 경로의 NLog.config를 수정하면 위 생성자가 자동 호출되며 치트코드를 로드할 수 있습니다.
   
   **블스설치경로\StreamingAssets\NLog.config**
   <?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
      autoReload="true"
      throwExceptions="false"
      internalLogLevel="Off" internalLogFile="d:\temp\nlog-internal.log">

  <!-- optional, add some variables
  https://github.com/nlog/NLog/wiki/Configuration-file#variables
  -->

  <!--
  See https://github.com/nlog/nlog/wiki/Configuration-file
  for information on customizing logging rules and outputs.
   -->
  <targets>

    <!--
    add your targets here
    See https://github.com/nlog/NLog/wiki/Targets for possible targets.
    See https://github.com/nlog/NLog/wiki/Layout-Renderers for the possible layout renderers.
    -->

    <!--
    Write events to a file with the date in the filename.
    <target xsi:type="File" name="f" fileName="${basedir}/logs/${shortdate}.log"
            layout="${longdate} ${uppercase:${level}} ${message}" />
    -->
    <target name="fileDebugTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-debug-${var:instanceName}.log"
            deleteOldFileOnStartup="true"
            openFileCacheTimeout="30"
            encoding="utf-8"
            createDirs="true"
    />
    <target name="NLogTarget" xsi:type="NLogTarget"
	/>

	<target name="fileDebugTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-debug-${var:instanceName}.log"
            deleteOldFileOnStartup="true"
            openFileCacheTimeout="30"
            encoding="utf-8"
            createDirs="true"
    />
    <target name="fileInfoTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-info-${var:instanceName}-${shortdate}.log"
            openFileCacheTimeout="30"
            createDirs="true"
    />
  </targets>

  <rules>
        <logger name="*" minlevel="Debug" writeTo="NLogTarget" />
  </rules>
</nlog>
   
   
 ## 위 내용을 이해했다면 정말 단순한 해킹을 만드는 순서입니다
 1. 블랙서바이벌 dll 참조한다음 해킹을 만듭니다. 
 2. NLogTarget.cs를 만든후 해당 클래스에 위 적힌대로 Attribute를 적용하고, TargetWithLayout를 상속받습니다. 그리고 생성자에 치트코드 로드하는 코드 작성합니다.
 3. 컴파일해서 컴파일하는 DLL이름을  NLogXXXX.dll로 하고 파일을 단순히 게임 dll이 있는 경로에 추가합니다.
 4. NLogConfig 파일 수정해서 2번에서 생성한 NLogTarget.cs 호출되게 만들어줍니다.
 5. 1,2,3,4를 마쳤다면 게임을 실행하면 치트코드가 자동으로 로드됩니다~~
 
 
 
   
