# MonoExploit
   ![](https://i.imgur.com/vEv9xTH.png)
   
## 개요 
 기본적으로 .Net에서 제공하는 Assembly.Load함수를 이용하면 다른 어셈블리를 AppDomain에 연결시킬 수 있다. 
 하지만 일반적으로 이 Assembly.Load조차 외부에서 호출하기 위해서는 결국 AssemblyChsarp.dll 파일을 해킹변조 해야한다.
 
 다만, Assembly.Load를 자체적으로 호출 하는 프로세스라면 이야기가 다르다. 이게 무슨말이냐면 특정 패턴이나 경로에 의존하여
 Assembly.Load를 플러그인 형식으로 로드하여 리플렉션으로 호출하는 경우가있다. **NLog**의 취약점을 예로 들어보자.
 
## NLog를 사용하는 Assembly.Load의 취약점 해킹하기
 **NLog** 내부의 ConfigurationItemFactory.cs를 확인해보자.
 
```cs
 private static void LoadNLogExtensionAssemblies(
      ConfigurationItemFactory factory,
      Assembly nlogAssembly,
      string[] extensionDlls)
    {
      HashSet<string> stringSet = new HashSet<string>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase)
      {
        nlogAssembly.FullName
      };
      foreach (string extensionDll in extensionDlls)
      {
        InternalLogger.Info<string>("Auto loading assembly file: {0}", extensionDll);
        bool flag = false;
        try
        {
          Assembly assembly = AssemblyHelpers.LoadFromPath(extensionDll, (string) null);
          InternalLogger.LogAssemblyVersion(assembly);
          factory.RegisterItemsFromAssembly(assembly);
          stringSet.Add(assembly.FullName);
          flag = true;
        }
        catch (Exception ex)
        {
          if (ex.MustBeRethrownImmediately())
          {
            throw;
          }
          else
          {
            object[] objArray = new object[1]
            {
              (object) extensionDll
            };
            InternalLogger.Warn(ex, "Auto loading assembly file: {0} failed! Skipping this file.", objArray);
          }
        }
        if (flag)
          InternalLogger.Info<string>("Auto loading assembly file: {0} succeeded!", extensionDll);
      }
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
    }
```
    
    맨 아래에 아래와같은 코드를 확인 할 수 있다.
    
```cs
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
``` 
 
     NLog로 시작하는 DLL파일을 Assembly.Load시키는 명령이다. 위 코드는 NLog가 Initalize될때 NLog로 시작하는 dll이 있으면 앱 도메인에 연결시킨다.  
    
   ## 실제 사용
   
   **블랙서바이벌** 이라는 게임을 대상으로 이 취약점을 이용하여 게임을 해킹해볼 예정이다.
   1. DnSpy & DotPeek같은 프로그램으로 게임의 루틴&구조를 파악한다.
   2. 본인만의 코드를 작성한다. 싱글턴으로 작성하는것을 추천.  
   3. 이후 본인의 코드를 실행하기위한 Static Method를 하나 작성해야함. **class A{ static void B(){load cheat..}}** 이후 **NLogCheat.dll** 등의 이름으로 컴파일해서 폴더에 복사한다
   4. static 함수 호출을 위해 치트엔진 등의 프로그램으로 **Mono Dissector**를 이용하여 함수 시그니처를 검색한다.
   5. 00 00 00 ?? 00 00 00... 등 형식의 시그니처를 RemoteThread를 생성하여 Call한다.
   
 
   
   
