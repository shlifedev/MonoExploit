# MonoExploit
 NLog의 취약점을 이용하여 앱 도메인에 어셈블리를 로드합니다. 
   ![](https://i.imgur.com/vEv9xTH.png)
   
   [Blog Post](https://shlifedev.tistory.com/1)
   
## 개요 
 기본적으로 .Net에서 제공하는 Assembly.Load함수를 이용하면 다른 어셈블리를 AppDomain에 연결시킬 수 있습니다.   
 다만, Assembly.Load를 프로세스 자체적으로 호출 하는 라이브러리를 찾으면 게임을 쉽게 해킹할 수 있습니다. 
 
 Mono 빌드에서 NLog를 사용하는 경우의 취약점이며, 어플리케이션이 dll 로드를 허용하는 부분이기에
 안티치트를 도입해도 취약할 수 있는 부분입니다.
 
 
## NLog를 사용하는 Assembly.Load의 취약점 해킹하기
 **NLog** 내부의 ConfigurationItemFactory.cs를 확인해봅시다.
 
```cs
 private static void LoadNLogExtensionAssemblies(
      ConfigurationItemFactory factory,
      Assembly nlogAssembly,
      string[] extensionDlls)
    {
      HashSet<string> stringSet = new HashSet<string>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase)
      {
        nlogAssembly.FullName
      };
      foreach (string extensionDll in extensionDlls)
      {
        InternalLogger.Info<string>("Auto loading assembly file: {0}", extensionDll);
        bool flag = false;
        try
        {
          Assembly assembly = AssemblyHelpers.LoadFromPath(extensionDll, (string) null);
          InternalLogger.LogAssemblyVersion(assembly);
          factory.RegisterItemsFromAssembly(assembly);
          stringSet.Add(assembly.FullName);
          flag = true;
        }
        catch (Exception ex)
        {
          if (ex.MustBeRethrownImmediately())
          {
            throw;
          }
          else
          {
            object[] objArray = new object[1]
            {
              (object) extensionDll
            };
            InternalLogger.Warn(ex, "Auto loading assembly file: {0} failed! Skipping this file.", objArray);
          }
        }
        if (flag)
          InternalLogger.Info<string>("Auto loading assembly file: {0} succeeded!", extensionDll);
      }
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
    }
```
    
    잘 보면 맨 아래에 아래와같은 코드를 확인 할 수 있습니다.
    
    
```cs
      foreach (Assembly assembly in LogFactory.CurrentAppDomain.GetAssemblies())
      {
        if (assembly.FullName.StartsWith("NLog.", StringComparison.OrdinalIgnoreCase) && !stringSet.Contains(assembly.FullName))
          factory.RegisterItemsFromAssembly(assembly);
        if (assembly.FullName.StartsWith("NLog.Extensions.Logging,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("NLog.Web,", StringComparison.OrdinalIgnoreCase) || (assembly.FullName.StartsWith("NLog.Web.AspNetCore,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging,", StringComparison.OrdinalIgnoreCase)) || (assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Abstractions,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Extensions.Logging.Filter,", StringComparison.OrdinalIgnoreCase) || assembly.FullName.StartsWith("Microsoft.Logging,", StringComparison.OrdinalIgnoreCase)))
          LogManager.AddHiddenAssembly(assembly);
      }
``` 
 
    
  
   NLog로 시작하는 DLL파일을 Assembly.Load시키는 명령입니다. 위 코드는 NLog가 Initalize될때 NLog로 시작하는 dll이 있으면 앱 도메인에 연결시킵니다.
   이걸실제 게임에 적용하는 방법입니다.
   
   일단 아래와 같은 코드를 작성합니다
   
   ```cs
   using NLog.Targets;
[Target(nameof(NLogTarget))] 
public sealed class NLogTarget : TargetWithLayout
{ 
    public NLogTarget()
    {
        StaticLoader.StaticLoad();
    }
}
   ```
  위 코드는 Target Attribute를 적용하고 TargetWithLayout을 상속시켜 NLog가 해당 .ctor를 자동 호출하게 만듭니다.
  그다음 아래 경로의 NLog.config를 수정하면 위 생성자가 자동 호출되며 치트코드를 로드할 수 있습니다.
   
   **블스설치경로\StreamingAssets\NLog.config**
   <?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.nlog-project.org/schemas/NLog.xsd NLog.xsd"
      autoReload="true"
      throwExceptions="false"
      internalLogLevel="Off" internalLogFile="d:\temp\nlog-internal.log">

  <!-- optional, add some variables
  https://github.com/nlog/NLog/wiki/Configuration-file#variables
  -->

  <!--
  See https://github.com/nlog/nlog/wiki/Configuration-file
  for information on customizing logging rules and outputs.
   -->
  <targets>

    <!--
    add your targets here
    See https://github.com/nlog/NLog/wiki/Targets for possible targets.
    See https://github.com/nlog/NLog/wiki/Layout-Renderers for the possible layout renderers.
    -->

    <!--
    Write events to a file with the date in the filename.
    <target xsi:type="File" name="f" fileName="${basedir}/logs/${shortdate}.log"
            layout="${longdate} ${uppercase:${level}} ${message}" />
    -->
    <target name="fileDebugTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-debug-${var:instanceName}.log"
            deleteOldFileOnStartup="true"
            openFileCacheTimeout="30"
            encoding="utf-8"
            createDirs="true"
    />
    <target name="NLogTarget" xsi:type="NLogTarget"
	/>

	<target name="fileDebugTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-debug-${var:instanceName}.log"
            deleteOldFileOnStartup="true"
            openFileCacheTimeout="30"
            encoding="utf-8"
            createDirs="true"
    />
    <target name="fileInfoTarget" xsi:type="File"
            layout="[${level:uppercase=true}] | ${message}"
            fileName="${var:logPath}-info-${var:instanceName}-${shortdate}.log"
            openFileCacheTimeout="30"
            createDirs="true"
    />
  </targets>

  <rules>
        <logger name="*" minlevel="Debug" writeTo="NLogTarget" />
  </rules>
</nlog>
   
   
 
 
   
